[[programming-model]]
= Programming Model

:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:page-partial:


Choices, defaults and auto-complete are defined using supporting methods, whose name has an appropriate prefix and returns the appropriate data type.
But there are several different conventions available; choose the one that works best for you.

== Choices

A drop-down list of _choices_ for a property are specified using:

[source,java]
.Customer.java
----
import lombok.Getter;
import lombok.Setter;

public class Customer {

    @Property(editing = Editing.ENABLED)                    // <.>
    @Getter @Setter
    private String paymentMethod;

    public List<String> choicesPaymentMethod() {            // <.>
        return Arrays.asList("Visa", "Mastercard", "Amex");
    }

    // ...
}
----
<.> If required; properties are by default disabled globally.
<.> Note the "choices" prefix and the suffix matching up with the getter.
The method must return a collection of the same type as the property.

For an action, the _choices_ for the N-th parameter can be specified by "number":

[source,java]
.Customer.java
----
public class Customer {

    public Order invoice(
            ShoppingCart cart,
            String paymentMethod,
            DiscountVoucher voucher,
            LocalDate shipBy) {
        ...
        return this;
    }

    public List<String> choices1Invoice() {         // <.>
        return this.getPaymentMethods();
    }

    // ...
}
----
<.> "choices" prefix, N-th param, suffix matches up with the action's name. +
Returns a collection of the same type as the parameter.


== Default

For properties, there is no concept of a default value ; just initialize the field to an appropriate value the object is created.
For actions, though, providing a default value for its parameters can substantially improve the user experience.

For an action, the _choices_ for the N-th parameter can be specified by "number":

[source,java]
.Customer.java
----
public class Customer {

    public Order invoice(
            ShoppingCart cart,
            String paymentMethod,
            DiscountVoucher voucher,
            LocalDate shipBy) {
        ...
        return this;
    }

    public String default1Invoice() {       // <.>
        return this.getPaymentMethod();     // <.>
    }

    // ...
}
----
<.> "default" prefix, N-th param, the suffix matches up with the action's name. +
Returns object of same type as parameter.
<.> A common idiom is to return the current value of a property of the object.



== AutoComplete

The _autocomplete_ is similar to _choices_, but accepts a string parameter, to search for matching results.
A property for example might have:

[source,java]
.Order.java
----
public class Order {

    @Property(editing = Editing.ENABLED)                        // <.>
    @Getter @Setter
    private Product product;

    public List<Product> autoCompleteProduct(                   // <.>
                            @MinLength(2) String search) {      // <.>
        return productRepository.findByReferenceOrName(search);
    }

    // ...
}
----
<.> If required; properties are by default disabled globally.
<.> "autoComplete" prefix, suffix matches property name. +
Returns a collection of the property's type.
<.> The `@MinLength(...)` annotation indicates the minimum number of characters that must be entered before a search is initiated.

Actions are very similar.
Here the supporting "autoComplete" method is matched by number:

[source,java]
.Order.java
----
public class Order {

    public Order changeProduct(Product product) {
        setProduct(product);
        return this;
    }

    public List<Product> autoComplete0Product(                  // <.>
                            @MinLength(2) String search) {
        return productRepository.findByReferenceOrName(search);
    }

    // ...
}
----
<.> "autoComplete" prefix, N-th param, suffix matches action name. +
Returns a collection of the parameters type.

An _autoComplete_ method can be used in conjunction with a _default_ method, but it doesn't make sense to provide both an _autoComplete_ and a _choices_ method.



== "Globally" defined drop-downs

Very often the set of available choices depends on the data type of the property/action parameter, rather than the individual property/parameter itself.
And similarly the algorithm to search for references again may well depend only on that reference type.

In the case of _choices_, annotating a class as "bounded" (as in a "bounded" or fixed number of instances) means that a _choices_ drop-down will automatically be defined.
For example:

[source,java]
----
@DomainObject(
    bounded = true
)
public class Product { /* ... */ }
----

For more on this, see xref:refguide:applib:index/annotation/DomainObject.adoc#bounding[@DomainObject#bounding].

Or, if the data type is an enum, then a drop-down will be provided automatically.
A payment method is a good example of this:


[source,java]
----
public enum PaymentMethod {
    VISA, MASTERCARD, AMEX;
}
----

Something similar can be achieved for _autoComplete_.
Here the domain object indicates a repository query to execute.
For example:

[source,java]
----
@DomainObject(
    autoCompleteRepository = Customers.class,
    autoCompleteMethod = "findByReferenceOrName"
)
public class Customer { /* ... */ }
----

with:

[source,java]
----
@DomainService(nature = NatureOfService.VIEW)
public class Customers {
    @Action(semantics=SemanticsOf.SAFE)
    public List<Customer> findByReferenceOrName(@MinLength(3) String refOrName) {
        ...
    }
}
----

For more on this, see xref:refguide:applib:index/annotation/DomainObject.adoc#autoCompleteRepository[@DomainObject#autoCompleteRepository].

[TIP]
====
There's no need for the nominated method to be an actual action; any method of any domain service will do, so long as it accepts a string and returns the correct list.
====


== Multi-select action parameters

As well as scalar values, action parameters can also be collections.
For this to be valid, a _choices_ or _autoComplete_ supporting method must be provided.

For example, suppose we want to "tag" or "label" an object:

[source,java]
----
public StoryCard tag(List<Tag> tags) {
    getTags().addAll(tags);
}

public List<Tag> autoCompleteTag(@MinLength(1) search) {
    return tagRepository.findByName(search);
}
----


If the action has been associated with a collection, using xref:refguide:applib:index/annotation/Action.adoc#choicesFrom[@Action#choicesFrom()], then the collection can be used to provide a list of candidate values.

The xref:vw:ROOT:about.adoc[Web UI (Wicket viewer)] handles this by rendering checkboxes against the associated collection; the user can select/deselect these checkboxes and the selected items are taken as the values for the multi-select action.



== Dependent choices for action parameters

For action it is also possible (in a limited form) to define dependencies between parameters.
Specifically, if one parameter is a drop-down choice, then other drop-down choices can be derived from it.

A good example is a category/sub-category:

[source,java]
----
public ToDoItem categorize(
            Category category,
            Subcategory subcategory) {
    setCategory(category);
    setSubcategory(subcategory);
}

public List<Category> choices0Categorize() {
    return categoryRepository.allCategories();
}
public List<Subcategory> choices1Categorize(        // <.>
                                Category category) {
    return subcategoryRepository.findBy(category);
}
----
<.> Returns a list of choices for the 2nd parameter based on the argument provided for the first.

p

